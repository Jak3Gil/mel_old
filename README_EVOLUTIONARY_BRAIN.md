# 🧠 Hardened Evolutionary Brain Simulation Framework

This implementation adds a **hardened** evolutionary brain simulation framework to the Melvin memory system, where 100 "brains" (parameterized memory/graph systems) ingest continuous data streams, form long-term memories, and are periodically probed with reasoning questions. Brains are evaluated, ranked, evolved, and respawned in a continuous loop.

## 🛡️ Hardening Features

This framework implements **10 critical hardening measures** to ensure real evolution rather than just I/O churn:

1. **Binary Memory Layout** - Aligned with Melvin's binary file spec using reserved codes
2. **2-bit Relation Codes** - 00=Exact, 01=Temporal, 10=Leap (11 reserved)
3. **Sensory Data Streams** - Audio frame tokens and image embeddings matching sensory outline
4. **Deterministic Seeds** - master_seed → gen_seed → brain_seed hierarchy
5. **Constrained Parallelism** - Bounded workers and batched ingestion
6. **Crash Containment** - Brain quarantine and respawn from elite parent
7. **I/O Budget Tracking** - Bytes written + syscalls as fitness penalty
8. **Precise Metrics** - 10-bin ECE calibration and N=5 self-consistency
9. **Multi-hop Probes** - Temporal chains and leap bridges
10. **Thought Replay Audits** - 1110 thought nodes with contradiction detection

## 🎯 Core Concepts

### Brain = Genome + Memory
- **Genome**: A JSON dict of hyperparameters (reinforcement rules, beam width, abstraction triggers, etc.)
- **Memory**: Append-only binary file (nodes, edges, thought traces) as per Melvin's design

### Population: 100 brains running in parallel
- Each brain has unique hyperparameters
- All brains consume the same data stream
- Performance is evaluated through reasoning probes

### Data: Continuous event streams
- **Facts/relations**: Small triplets ("cats drink water", "dogs chase cats")
- **Patterns/rules**: Sequences requiring transitive reasoning
- **Perceptual codes**: Audio/image embeddings (randomly generated byte payloads)
- **Noise/drift**: Distribution shifts, irrelevant fragments

### Probes: Periodic reasoning tasks
- **Multi-hop depth**: Questions requiring 2–4 steps
- **Abstraction use**: Test if abstractions help answer
- **Remote recall**: Query facts first seen >N events ago
- **Consistency**: Ask paraphrased questions, measure contradiction rate
- **Calibration**: Compare confidence vs correctness (ECE)
- **Efficiency**: Log latency, nodes touched, memory footprint

### Selection: Tournament + elitism
- Best genomes survive, bottom ones replaced via mutation/crossover
- Top 10% elite, 70% mutation, 20% crossover

## 🧬 Hardened Genome Structure

```json
{
  "id": "B042",
  "seed": 23145678,
  "ingest": { 
    "temporal_weight_inc": 1.0, 
    "leap_init": 1.0, 
    "leap_create_prob": 0.06 
  },
  "reason": { 
    "beam_width": 8, 
    "max_hops": 6, 
    "leap_bias": 0.15, 
    "abstraction_thresh": 0.78 
  },
  "storage": { 
    "mmap": true, 
    "flush_interval": 2048, 
    "index_stride": 256 
  },
  "sensors": { 
    "audio_cluster_thresh": 0.62, 
    "image_sim_thresh": 0.78 
  }
}
```

## 🏗️ Architecture

### Core Classes

1. **`Genome`** - Hyperparameter configuration with evolution operations
2. **`EvolutionaryBrain`** - Brain combining genome + Melvin memory system
3. **`DataStreamGenerator`** - Generates continuous data streams
4. **`ProbeSystem`** - Evaluates brain performance with reasoning tasks
5. **`EvolutionOrchestrator`** - Manages population, evolution cycles
6. **`BrainSimulationRunner`** - High-level simulation controller

### Key Features

- **Parallel Processing**: All 100 brains run concurrently
- **Continuous Evolution**: Every 50k events, brains are evaluated and evolved
- **Comprehensive Metrics**: Accuracy, multi-hop reasoning, abstraction use, efficiency
- **Persistent Storage**: All brain memories, genomes, and metrics are saved
- **Modular Design**: Easy to extend with new probe types, data generators, or evolution strategies

## 🚀 Usage

### Build the System
```bash
make all
```

### Run the Demo
```bash
make run-demo
```

### Run Sanity Check (3 generations)
```bash
make sanity-check
```

### Run Full Evolution (100 generations)
```bash
make full-evolution
```

### Run Tests
```bash
make test
```

### Build for Development
```bash
make debug
```

### Build for Production
```bash
make release
```

## 📊 Output Structure

The simulation creates the following directory structure:

```
hardened_brain_simulation/
├── genomes/           # JSON configurations for each brain
├── metrics/           # CSV files with performance metrics
├── thoughts/          # Reasoning traces and thought logs
└── brains/            # Individual brain memory data
    ├── B000/
    │   ├── mem.log    # Binary memory log (mmap'd)
    │   └── index.sqlite # Optional index
    ├── B001/
    └── ...
```

### Metrics CSV Format
```
generation,brain_id,fitness,accuracy,multihop,abstraction,remote_recall,ece,self_consistency,contradiction_rate,efficiency,bytes_written,syscalls,time_ms
```

## 🧪 Hardened Fitness Function

The fitness of each brain is calculated as:

```
Fitness = 
  0.3 * Accuracy +
  0.15 * MultiHopScore +
  0.1 * AbstractionUse +
  0.1 * RemoteRecall +
  0.1 * (1 - ECE) +
  0.1 * SelfConsistency -
  0.05 * ContradictionRate +
  0.1 * EfficiencyScore
```

Where:
- **ECE**: 10-bin calibration of brain's confidence vs empirical accuracy
- **Self-Consistency**: Majority agreement over N=5 independent traversals
- **EfficiencyScore**: Includes I/O budget penalty (bytes_written + syscalls)

## 🔄 Hardened Evolution Cycle

1. **Data Ingestion**: All brains consume 50k events from the data stream
2. **Evaluation**: Each brain is probed with reasoning questions
3. **Ranking**: Brains are sorted by fitness score
4. **Selection**: Top 10% become elite, rest are replaced
5. **Reproduction**: New brains created via mutation (70%) and crossover (20%)
6. **Respawn**: New population continues with next generation
7. **Crash Containment**: Quarantined brains are respawned from elite parents
8. **Thought Replay**: 5% of correct answers are replayed for consistency

## 🎛️ Configuration

Key parameters can be adjusted in the `EvolutionOrchestrator` class:

- `POPULATION_SIZE`: Number of brains (default: 100)
- `EVALUATION_WINDOW`: Events per generation (default: 50,000)
- `ELITE_RATIO`: Fraction of elite brains (default: 0.1)
- `MUTATION_RATIO`: Fraction of mutated offspring (default: 0.7)
- `CROSSOVER_RATIO`: Fraction of crossover offspring (default: 0.2)

### Sanity Check Playbook

**Gen 0 (Smoke Test)**: Population 20, Events 5k
- Expect >90% probe replays to serialize 1110 thought nodes
- Bytes/solve under fixed budget

**Gen 1 (Pressure Test)**: Population 50, Events 25k
- Ensure ECE drops and Self-Consistency rises
- Verify I/O budget isn't exploding

**Gen 2 (Scale Test)**: Population 100, Events 50k
- Check elite diversity (genomes not collapsing to same params)
- If collapse: raise crossover rate, add novelty bonus

## 🔬 Research Applications

This framework enables research into:

- **Cognitive Architecture**: How different memory and reasoning parameters affect performance
- **Evolutionary Dynamics**: How populations of reasoning systems evolve over time
- **Abstraction Learning**: How brains develop and use abstract concepts
- **Memory Efficiency**: Trade-offs between memory usage and reasoning capability
- **Robustness**: How systems handle noise, drift, and distribution shifts

## 🎯 Success Indicators

By Gen 5–8, you should see:

- **Fitness rising** mainly via MultiHop, (1-ECE), and Self-Consistency
- **No corresponding bytes_written/probe increase** (smarter, not louder)
- **Leap:Temporal edge ratio** stabilizing (~0.2–0.35) with meaningful variation
- **Thought-node replays** reproducing >95% of prior correct answers
- **Contradiction rate** continuing to fall
- **Elite diversity** maintained (genomes not collapsing to same params)

## 🛠️ Extending the Framework

### Adding New Probe Types
1. Add new probe generation methods to `ProbeSystem`
2. Implement corresponding metric calculation
3. Update the fitness function weights

### Adding New Data Generators
1. Extend `DataStreamGenerator` with new event types
2. Update the event distribution probabilities
3. Ensure new data types are compatible with Melvin's learning system

### Custom Evolution Strategies
1. Modify the `evolve_population()` method in `EvolutionOrchestrator`
2. Implement new selection, mutation, or crossover strategies
3. Add speciation or diversity preservation mechanisms

## 📈 Monitoring and Analysis

The system exports comprehensive metrics for analysis:

- **Generation-level**: Average, best, and worst fitness per generation
- **Brain-level**: Individual performance metrics for each brain
- **Genome-level**: Complete hyperparameter configurations
- **Thought-level**: Reasoning traces and decision processes

Use these outputs to analyze evolutionary trends, identify successful parameter combinations, and understand how different cognitive architectures perform under various conditions.

## 🔧 Dependencies

- C++17 or later
- Standard library components (filesystem, threading, etc.)
- Melvin memory system (included)

## 📝 License

This evolutionary brain simulation framework is part of the Melvin project and follows the same licensing terms.
